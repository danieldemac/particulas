<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>Simulação de Partículas - Gravidade</title>
	<link rel="stylesheet" type="text/css" href="css/reset.css">
	<link rel="stylesheet" type="text/css" href="css/styles3.css">
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Ysabeau+SC:wght@200&display=swap" rel="stylesheet">
</head>
<body>


<canvas id="life" width="1000" height="1000"></canvas>
<script>
  const canvas = document.getElementById("life");
    const m = canvas.getContext("2d");
    const particles = [];
    const particleRadius = 5;
    const resistance = 0.01;
    const restitution = 0.01; // Coeficiente de restituição (0 = inelástico, 1 = elástico)

    const draw = (x, y, c, s) => {
      m.fillStyle = c;
      m.beginPath();
      m.arc(x, y, s / 2, 0, 2 * Math.PI);
      m.fill();
    };

    const particle = (x, y, c) => {
      return { x, y, vx: (Math.random() - 0.5) * 2, vy: (Math.random() - 0.5) * 2, color: c };
    };

    const random = () => Math.random() * (canvas.width - 100) + 50;

    const create = (number, color) => {
      const group = [];
      for (let i = 0; i < number; i++) {
        let p = particle(random(), random(), color);
        group.push(p);
        particles.push(p);
      }
      return group;
    };

    const rule = (particles1, particles2, g) => {
      for (let i = 0; i < particles1.length; i++) {
        let fx = 0, fy = 0;
        for (let j = 0; j < particles2.length; j++) {
          if (i !== j) {
            const a = particles1[i];
            const b = particles2[j];
            const dx = b.x - a.x;
            const dy = b.y - a.y;
            const d = Math.sqrt(dx * dx + dy * dy);

            if (d > 0 && d < 50) {
              const F = (g * 1) / d;
              a.vx += (F * dx);
              a.vy += (F * dy);
            }
            handleCollision(a, b); // Verifica e ajusta colisão
          }
        }
      }
    };

    const handleCollision = (a, b) => {
      const dx = b.x - a.x;
      const dy = b.y - a.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      const minDistance = particleRadius * 2;

      if (distance < minDistance) {
        const nx = dx / distance;
        const ny = dy / distance;
        const dvx = b.vx - a.vx;
        const dvy = b.vy - a.vy;
        const dotProduct = dvx * nx + dvy * ny;
        if (dotProduct > 0) return;

        const impulse = (2 * dotProduct) / 2;
        a.vx -= impulse * nx * restitution;
        a.vy -= impulse * ny * restitution;
        b.vx += impulse * nx * restitution;
        b.vy += impulse * ny * restitution;

        const overlap = minDistance - distance;
        a.x -= nx * overlap / 1.01;
        a.y -= ny * overlap / 1.01;
        b.x += nx * overlap / 1.01;
        b.y += ny * overlap / 1.01;
      }
    };

    const red = create(50, "red");
    const yellow = create(50, "yellow");
    const green = create(50, "green");
    const blue = create(50, "blue");

    const update = () => {
      rule(red, red, -0.01);
      rule(yellow, yellow, 0.01);
      rule(green, green, 0.01);
      rule(blue, blue, -0.1);

      rule(yellow, red, 0.1);
      rule(red, yellow, 0);
      
      rule(green, red, 0.5);
      rule(red, green, 0);
      
      rule(green, yellow, -0.01);
      rule(yellow, green, 0.02);

      rule(blue, red, 0.01);
      rule(red, blue, 0);
      
      rule(blue, yellow, -0.01);
      rule(yellow, blue, 0.01);
      
      rule(blue, green, -0.01);
      rule(green, blue, 0.01);

      m.fillStyle = "black";
      m.fillRect(0, 0, canvas.width, canvas.height);

      for (let i = 0; i < particles.length; i++) {
        let p = particles[i];
        p.x += p.vx;
        p.y += p.vy;

        p.vx *= (1 - resistance);
        p.vy *= (1 - resistance);

        if (p.x <= particleRadius || p.x >= canvas.width - particleRadius) p.vx *= -1;
        if (p.y <= particleRadius || p.y >= canvas.height - particleRadius) p.vy *= -1;

        draw(p.x, p.y, p.color, particleRadius);
      }
      window.requestAnimationFrame(update);
    };

    update();


</script>




	
</body>
</html>